-- 5 -> Переведите законы класса Monad на язык (>>=)

----------- 1 -------------
return >=> k == k -- эта-экспансия:
\a -> (return >=> k) a == \a -> k a -- применяем определение рыбки через байнд
\a -> return a >>= k == \a -> k a -- убираем абстракцию
return a >>= k == k a  -- получили закон 1


----------- 2 -------------
k >=> return == k -- применяем определение рыбки через байнд
\a -> (k a) >>= return == k -- эта-экспансия справа
\a -> (k a) >>= return == \a -> k a -- убираем абстракцию
k a >>= return == k a -- но k a это m
m >>= return == m -- получили закон 2

----------- 3 -------------
(u >=> v) >=> w == u >=> (v >=> w)

-- left side:
(u >=> v) >=> w -- дважды по определению рыбки
(\b -> u b >>= v) >=> w
\b -> (\a -> u a >>= v) b >>= w -- подстановку во внутреннюю абстракцию
\b -> (u b >>= v) >>= w -- подстановку во внутреннюю абстракцию

-- right side:
u >=> (v >=> w) -- дважды по определению рыбки
u >=> (\a -> v a >>= w)
\b -> u b >>= (\a -> v a >>= w)

\b -> (u b >>= v) >>= w      ==   \b -> u b >>= (\a -> v a >>= w) -- снимаем абстракцию
(u b >>= v) >>= w == u b >>= (\a -> v a >>= w) -- но u b это какая-то m
(m >>= v) >>= w == m >>= (\a -> v a >>= w) -- переименуем a в x для красоты
(m >>= v) >>= w == m >>= (\x -> v x >>= w) -- получили закон 3.

------------------------------------------------------------------------------------------------------------------

-- 4 (HW) -> Переведите законы класса Monad на язык join и fmap, используя представление (>=>) через join (и fmap).
-- Вот оно: (>==>) k1 k2 = join . fmap k2 . k1

----------- 1 -------------
return >=> k == k -- применяем определение рыбки через join-fmap
join . fmap k . return == k -- применяем  "return . f ==  fmap f . return"
join . return . k == k -- а отсюда очевидно: применить сначала k, потом return, потом join это то же, что применить просто k, значит вся левая часть это id
join . return == id -- поулчили первый закон

----------- 2 -------------
k >=> return == k -- применяем определение рыбки через join-fmap
join . fmap return . k == k -- а отсюда очевидно: применить сначала k, потом famp return, потом join это то же, что применить просто k, значит вся левая часть это id
join . fmap return  == id -- поулчили второй закон

----------- 3 -------------
(u >=> v) >=> w == u >=> (v >=> w)

-- left side:
(u >=> v) >=> w -- применяем дважды определение рыбки через join-fmap
(join . fmap v . u) >=> w 
join . fmap w . join . fmap v . u  -- fmap w . join = join . fmap (fmap w) -- 2-ая "свободная" теорема
join . join . fmap (fmap w) . fmap v . u -- fmap (fmap w) . fmap v = fmap (fmap w . v) -- закон функторов
join . join . fmap (fmap w . v) . u

-- right side:
u >=> (v >=> w) -- применяем дважды определение рыбки через join-fmap
join . fmap (v >=> w) . u
join . fmap (join . fmap w . v) . u -- раскрываем fmap по закону функторов
join . fmap join . fmap (fmap w . v) . u

-- заменим fmap (fmap w . v) . u = g в обеих частях для наглядности
-- получаем
join . join . g == join . fmap join . g
-- отсюда
join . join == join . fmap join -- получили третий закон